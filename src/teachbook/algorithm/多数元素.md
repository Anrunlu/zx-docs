---
title: 只出现一次的数字
icon: fas fa-layer-group
author: 周子力
order: 2
category:
  - 教学文档
tag:
  - 
---
# 多数元素
## 1.题目描述
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

示例 1：

输入：nums = [3,2,3]
输出：3
示例 2：

输入：nums = [2,2,1,1,1,2,2]
输出：2
 

提示：
n == nums.length
1 <= n <= 5 * 10^4
-109 <= nums[i] <= 109
 

进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
## 2.分析
* 暴力破解
先遍历一次得到数据中的元素，然后再遍历数组，所以复杂度是O(n^2)
* 哈希表
可以用用哈希表来快速统计每个元素出现的次数。哈希表（Hash Table）：也叫做散列表。是根据关键码值（Key Value）直接进行访问的数据结构。

哈希表通过「键 key 」和「映射函数 Hash(key) 」计算出对应的「值 value」，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做「哈希函数（散列函数）」，存放记录的数组叫做「哈希表（散列表）」。
不同的key，不同的值
相同的key，相同的值

用哈希表来求解该问题，时间复杂度是O(n)

* 排序
先进行排序，然后再找到索引是中间的元素。
因为有排序，而最好的排序算法的时间复杂度是 O(nlogn)，所以使用排序，该算法的复杂度也是： O(nlogn)

## 3.代码
```python
# 哈希
import collections
def majorityElement( nums) -> int:
    counts = collections.Counter(nums) #提供了可哈希对象的计数功能
    return max(counts.keys(), key=counts.get)

if __name__ == '__main__':
    nums = [2,2,1,1,1,2,2]
    print(majorityElement(nums))
```