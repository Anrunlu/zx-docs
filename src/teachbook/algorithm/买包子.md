---
title: 买包子
icon: fas fa-layer-group
author: 李承昊
order: 10
category:
  - 教学文档
tag:
- 动态规划
---

# 题目描述

小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 Ai 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。比如一共有 3 种蒸笼，分别能放 3、4 和 5 个包子。当顾客想买 11 个包子时，大叔就会选 2 笼 3 个的再加 1 笼 5 个的（也可能选出 1 笼 3 个的再加 2 笼 4 个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 3 种蒸笼，分别能放 4、5 和 6 个包子。而顾客想买 7 个包子时，大叔就凑不出来了。

写出一个程序要求输入数组 A[i] 来表示这 N 种蒸笼分别能放多少包子（包子的上限为 10000），并计算出一共有多少种数目是包子大叔凑不出来的。

# 题目解析

这个问题可以视为一个背包问题的变种，其中每种蒸笼的容量对应背包问题中的物品重量，而我们要找的是哪些重量（即包子数量）是不能通过组合蒸笼来凑成的。在背包问题中，我们通常会计算哪些重量是可以凑成的，但在这里，我们需要反其道而行之，找出不能凑成的所有重量数量。

# 解题代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N; // 蒸笼种类数
    cin >> N;
    vector<int> A(N + 1); // 蒸笼容量数组，A[0] 不使用
    for (int i = 1; i <= N; ++i) {
        cin >> A[i]; // 读取每种蒸笼的容量
    }

    const int MAX_BUNS = 10000; // 假设包子数量的上限（根据题目情况调整）
    vector<bool> dp(MAX_BUNS + 1, false); // dp数组，初始化为false
    dp[0] = true; // 可以凑成0个包子

    // 动态规划填表
    for (int j = 1; j <= N; ++j) { // 遍历每种蒸笼
        for (int i = A[j]; i <= MAX_BUNS; ++i) { // 从当前蒸笼的容量开始向上遍历
            if (dp[i - A[j]]) { // 如果可以凑成i-A[j]个包子
                dp[i] = true; // 则可以加上一个当前蒸笼凑成i个包子
            }
        }
    }

    // 统计不能凑成的包子数量
    int count = 0;
    for (int i = 1; i <= MAX_BUNS; ++i) {
        if (!dp[i]) {
            ++count;
        }
    }

    cout << count << endl; // 输出结果

    return 0;
}
```

这段代码通过动态规划的方式解决了问题，首先初始化一个布尔数组 `dp`，其中 `dp[i]` 表示是否能凑成 `i` 个包子。然后，通过遍历每种蒸笼的容量，更新 `dp` 数组，最后统计 `dp` 数组中为 `false` 的元素数量，即为不能凑成的包子数量。