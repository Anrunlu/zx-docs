---
title: 摆花
icon: fas fa-layer-group
author: 刘丰瑞
order: 1
category:
  - 教学文档
tag:
  - 动态规划
---

# 摆花

## 1. 题目描述



小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

### 输入格式

第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。

第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。

### 输出格式

一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。

### 样例 #1

#### 样例输入 #1

```
2 4
3 2
```

#### 样例输出 #1

```
2
```

### 提示

【数据范围】

对于 $20\%$ 数据，有 $0<n \le 8,0<m \le 8,0 \le a_i \le 8$。

对于 $50\%$ 数据，有 $0<n \le 20,0<m \le 20,0 \le a_i \le 20$。

对于 $100\%$ 数据，有 $0<n \le 100,0<m \le 100,0 \le a_i \le 100$。

NOIP 2012 普及组 第三题

## 2. 分析

这个题是一道典型的动态规划，即可以从之前的状态推出后面的状态的最优解，先定义一个二维数
组，f[i][j]指摆第i个花后总共摆了j盆的最优解。

每次摆花的循环要从0开始，到t结束（题中是a[i]），即摆放t盆第i种花。

这个状态可以由上一个i的j转移过来，其中j+t要小于m（m是最多摆放的花盆数）。为防止变量冲突，代码里用的是k。

因为i总在i−1后面 则DP的状态转移方程为f[i][j+k]+=f[i−1][k];

最后，每做一次都要mod1000007，因为这个题不用max,min等函数，是从左向右推的过程，要在各个涉及ff数组的地方都要mod1000007。


例子：

输入

2 4

3 2

输出

2

## 3. 代码

```cpp
#include<cstdio>
#include<cstring>
#define mod 1000007
int max(int x,int y){return x>y?x:y;}
int f[101][101];//f[i][j]指摆第i个花后总共摆j盆的最优解
int main()
{
    int n,m,t;
    scanf("%d%d",&n,&m);
    memset(f,0,sizeof(f));
    for(int i=0;i<=n;i++)
        f[i][0]=1;
    for(int i=1;i<=n;i++)//枚举到第i盆花
    {
        scanf("%d",&t);
        for(int j=0;j<=t;j++)//第i盆花装j盆
            for(int k=0;k<=m-j;k++)//从已经装k盆转移过来
            {
                if(j==0&&k==0)
                    continue;
                f[i][j+k]+=f[i-1][k];
                f[i][j+k]%=mod;
            }
    }
    printf("%d\n",f[n][m]%mod);
    return 0;
}