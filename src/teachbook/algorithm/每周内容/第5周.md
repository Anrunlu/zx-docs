---
title: 第5周内容
icon: fas fa-layer-group
author: 周子力
order: 5
category:
  - 教学文档
tag:
  - 算法设计与分析
---

## 第5周内容


### 1.上周内容
（1）分治策略与分治算法设计模式及性质

寻找两个有序数组的中位数问题

从该问题中，我们可以学到：

- **算法思维：** 能否将问题转化为寻找分割点
- **边界处理能力：** 对各种边界情况的考虑是否全面
- **代码实现能力：** 能否写出简洁、正确的代码
- **复杂度分析：** 能否正确分析时间和空间复杂度


### 2.真题实战
(1) [连续数列](../递推和分治/连续数列.md)  分治法求解



### 一、代码实现中的注意事项

1.  **递归基（Base Case）的处理**：这是分治法最容易出错的地方。当子数组的长度为1时（即 `left == right`），不能再继续分割，此时最大子数组和就是该元素本身。必须正确处理这个边界条件，否则递归会无限进行下去或者产生错误结果。

2.  **“跨越中点”情况的精确计算**：这是分治法的核心，也是最容易写错的部分。
    *   **方向性**：计算左半部分的最大和时，必须**从中间点 `mid` 开始向左**遍历，并且**必须包含 `mid`**。同理，计算右半部分的最大和时，必须**从 `mid + 1` 开始向右**遍历，并且**必须包含 `mid + 1`**。不能反向计算，否则就无法保证子数组是连续且跨越中点的。
    *   **初始化**：左右两部分的初始和通常设为负无穷（或一个极小的数），但在累加过程中，第一个元素（`nums[mid]` 和 `nums[mid+1]`）必须被包含进来。
    *   **累加方式**：应该一边遍历一边累加，并实时更新当前找到的最大和，而不是先计算所有可能的和再取最大值，那样会增加不必要的复杂度。

3.  **返回值的正确比较**：在每一层递归中，必须正确地比较三种情况（左半部分最大值、右半部分最大值、跨越中点的最大值），并返回三者中的最大值。

4.  **数组索引的边界**：在分割数组和遍历时，要时刻注意数组的左右边界 `left` 和 `right`，避免数组越界错误。

### 二、对题目的思考

1.  **分治法的优劣**：
    *   **优点**：思路清晰，完美体现了“分而治之”的算法思想，将一个复杂问题分解为规模更小的相同子问题。对于理解递归和分治策略非常有帮助。
    *   **缺点**：时间复杂度为 **O(n log n)**。虽然优于暴力解法的 O(n²)，但存在更优的解法。例如，**动态规划（Kadane算法）** 可以在线性时间 **O(n)** 内解决此问题，空间复杂度也更低（O(1)）。因此，在实际工程应用中，动态规划通常是首选。

2.  **问题的本质**：这个问题考察的是如何在包含正负数的序列中，高效地找到一个局部最优的连续片段。负数是“破坏者”，会拉低总和；正数是“贡献者”。算法的核心在于如何聪明地“绕过”或“吸收”负数的影响。动态规划的思路是“如果之前的累计和是负的，那么从当前元素重新开始会更好”，这非常直观且高效。

3.  **三种情况的完备性**：分治法将问题分为“左”、“右”、“跨中”三种情况，这三种情况是**互斥且完备**的。任何一个连续子数组，其位置必然属于这三种情况之一，不会有遗漏。这是分治法能够正确求解此问题的理论基础。

4.  **扩展性思考**：如果题目稍作变化，比如要求返回最大和子数组的起始和结束索引，分治法和动态规划法都可以进行修改来实现，但动态规划法的修改通常更为直接。


（2）[连续序列](../动态规划/最大子数组和.md)  动态规划求解


## 代码中的注意事项

### 1. **初始化陷阱**
```python
# 错误写法
current_sum = max_sum = 0  # 对全负数数组会出错

# 正确写法  
current_sum = max_sum = nums[0]  # 用第一个元素初始化
```
- 必须考虑数组全为负数的边界情况
- 初始化为0会导致返回0，而实际应返回最大的负数

### 2. **循环边界处理**
```python
for num in nums[1:]:  # 从索引1开始，避免重复处理第一个元素
```
- 第一个元素已在初始化中处理
- 从第二个元素开始循环确保逻辑正确

### 3. **状态更新顺序**
```python
current_sum = max(num, current_sum + num)  # 先更新当前和
max_sum = max(max_sum, current_sum)       # 再更新全局最大
```
- 顺序不能颠倒，必须先计算当前状态再比较全局最优

### 4. **负数处理理解**
```python
# 关键洞察：不是遇到负数就重新开始
current_sum = max(num, current_sum + num)
```
- 只有当 `current_sum + num < num` 时才重新开始
- 这意味着之前的子数组和为负数，是负贡献

---

## 对题目的深度思考

### 1. **问题本质分析**
```python
# 将问题转化为：寻找最大的连续区间和
# 这等价于寻找累积和的最大差值
def alternative_solution(nums):
    prefix_sum = 0
    min_prefix = 0
    max_sum = nums[0]
    
    for num in nums:
        prefix_sum += num
        max_sum = max(max_sum, prefix_sum - min_prefix)
        min_prefix = min(min_prefix, prefix_sum)
    
    return max_sum
```
- 另一种思路：最大子数组和 = 最大前缀和差值
- 体现了问题的多角度可解性

### 2. **算法选择哲学**
- **暴力法 O(n²)**：理解问题本质，但不可行
- **分治法 O(nlogn)**：锻炼递归思维，但非最优
- **动态规划 O(n)**：最优解，体现计算机思维优势

### 3. **实际应用映射**
```python
# 股票买卖问题转化
prices = [7,1,5,3,6,4]
differences = [prices[i] - prices[i-1] for i in range(1, len(prices))]
# 最大子数组和就是最大利润
max_profit = maxSubArray(differences)
```
- 展示了算法问题的实际应用价值
- 培养"问题转化"的思维能力

---

## 从中学习到的内容

### 1. **动态规划核心思想**
```python
# 学习到DP三要素：
# 1. 状态定义：dp[i] - 以i结尾的最大子数组和
# 2. 状态转移：dp[i] = max(nums[i], dp[i-1] + nums[i])
# 3. 边界处理：dp[0] = nums[0]
```

### 2. **算法优化技巧**
```python
# 空间优化：从O(n)到O(1)
# 原始DP需要存储整个dp数组
dp = [0] * len(nums)
dp[0] = nums[0]

# 优化后只需两个变量
current_sum = max_sum = nums[0]
```
- **状态压缩**：当状态只依赖于前一个状态时，可以压缩空间
- **滚动数组**思想的简单应用

### 3. **边界情况处理能力**
```python
# 学到的测试用例思维
test_cases = [
    [-2,1,-3,4,-1,2,1,-5,4],  # 正常情况
    [1],                       # 单元素
    [-1,-2,-3],               # 全负数
    [5,4,-1,7,8],             # 全正数+负数
    [0,0,0,0]                 # 全零
]
```
- 培养全面的测试思维
- 理解极端情况对算法的影响

### 4. **问题分解能力**
```python
# 学习将复杂问题分解为子问题
def analyze_subproblem(nums, i):
    """分析第i个位置的决策"""
    choice1 = nums[i]          # 重新开始
    choice2 = current_sum + nums[i]  # 延续之前
    
    print(f"位置{i}: 重新开始={choice1}, 延续={choice2}, 选择={max(choice1, choice2)}")
    return max(choice1, choice2)
```
- 每个决策点只有两种选择，简化了思考
- 培养了"局部最优导致全局最优"的贪心思维

### 5. **代码健壮性意识**
```python
# 学到的防御性编程
def maxSubArray_robust(nums):
    if not nums:
        raise ValueError("数组不能为空")
    if len(nums) == 1:
        return nums[0]
    
    # 主逻辑...
```
- 输入验证的重要性
- 异常处理思维

### 6. **算法思维迁移**
```python
# 类似问题模式识别
# 1. 最大乘积子数组（类似但更复杂）
# 2. 最长递增子序列（不同DP思路）
# 3. 环形子数组最大和（此问题的变种）
```
- 建立了解决子数组问题的思维框架
- 为学习更复杂DP问题打下基础

### 7. **性能分析能力**
```python
# 学到的复杂度分析
"""
时间复杂度：O(n) - 单次遍历
空间复杂度：O(1) - 常数空间
最优性：理论上已是最优，必须遍历所有元素
"""
```
- 算法优劣的评判标准
- 时间/空间复杂度的权衡意识

---

## 总结收获

通过这道"简单"的题目，实际上学到了：

1. **核心算法思想**：动态规划的状态定义和转移方程
2. **优化技巧**：状态压缩和空间优化
3. **工程思维**：边界处理、测试用例设计
4. **问题解决能力**：分解复杂问题、模式识别
5. **实际应用**：算法到实际问题的映射能力

这正是"通过简单问题学习深刻思想"的典型案例，为后续学习更复杂的算法问题奠定了坚实基础。


### 3. 动态规划引入


## 动态规划的定义、条件与核心思想总结

基于最大子数组和问题的学习，可以系统总结出动态规划的相关内容：

---

## 一、动态规划的定义

**动态规划（Dynamic Programming）** 是一种通过将复杂问题分解为相互重叠的子问题，并存储子问题的解以避免重复计算，从而高效解决优化问题的算法思想。

```python
# 动态规划的本质：记忆化 + 子问题分解
def dp_solution(problem):
    if problem in memo: return memo[problem]  # 记忆化
    subproblems = decompose(problem)          # 分解
    solution = combine(subproblems)           # 合并
    memo[problem] = solution                  # 存储
    return solution
```

---

## 二、动态规划的适用条件

### 1. **最优子结构（Optimal Substructure）**
问题的最优解包含其子问题的最优解。

```python
# 在最大子数组和问题中的体现：
# 全局最大和必然包含以某个位置结尾的局部最大和
max_sum = max(dp[0], dp[1], ..., dp[n-1])
# 其中每个dp[i]都是子问题的最优解
```

**判断方法**：问题能否通过子问题的最优解推导出原问题的最优解。

### 2. **重叠子问题（Overlapping Subproblems）**
不同的决策路径会重复遇到相同的子问题。

```python
# 在最大子数组和问题中：
# 计算dp[i]时需要dp[i-1]，计算dp[i+1]时又需要dp[i]
# 存在递推关系，但本例中重叠不明显

# 更典型的例子：斐波那契数列
fib(n) = fib(n-1) + fib(n-2)  # fib(n-1)和fib(n-2)会被重复计算
```

**判断方法**：递归求解时是否存在大量重复计算。

### 3. **无后效性（No Aftereffect）**
当前状态确定后，后续决策只与当前状态有关，与如何到达此状态无关。

```python
# 在最大子数组和问题中：
dp[i] 只依赖于 dp[i-1] 和 nums[i]
# 与dp[i-1]是如何计算的无关（无论是从dp[i-2]延续还是重新开始）
```

**判断方法**：未来决策是否只依赖于当前状态值，不依赖于状态历史。

---

## 三、动态规划的核心要素

### 1. **状态定义（State Definition）**
明确dp数组或状态变量的含义。

```python
# 最大子数组和问题的状态定义：
dp[i] = 以第i个元素结尾的最大子数组和

# 其他常见状态定义：
# - dp[i][j]: 到达位置(i,j)的最优值
# - dp[mask]: 状态压缩，mask表示选择状态
# - dp[i][k]: 前i个元素，选择k个的最优值
```

### 2. **状态转移方程（State Transition Equation）**
描述状态之间的递推关系。

```python
# 核心方程：dp[i] = max(nums[i], dp[i-1] + nums[i])
# 通用形式：dp[i] = f(dp[i-1], dp[i-2], ..., 输入数据)
```

**推导技巧**：
- 考虑所有可能的决策选项
- 分析决策对状态的影响
- 写出数学表达式

### 3. **边界条件（Boundary Conditions）**
确定最小子问题的解。

```python
# 最大子数组和的边界：
dp[0] = nums[0]  # 只有一个元素时

# 其他常见边界：
# - dp[0] = 0 或 1（根据问题语义）
# - dp[i][0] = 初始值
# - 空集情况的处理
```

### 4. **计算顺序（Calculation Order）**
确定状态的计算方向。

```python
# 常见顺序：
# 1. 自底向上（迭代）：从边界开始逐步计算
for i in range(1, n):  # 从左到右
    dp[i] = max(nums[i], dp[i-1] + nums[i])

# 2. 自顶向下（记忆化递归）：从目标开始分解
@lru_cache
def dfs(i):
    if i == 0: return nums[0]
    return max(nums[i], dfs(i-1) + nums[i])
```

---

## 四、动态规划的解题步骤

### 步骤1：问题分析
- 判断是否满足最优子结构和重叠子问题
- 确定是求最大值、最小值还是方案数

### 步骤2：状态定义
- 用数学语言描述状态
- 确定状态维度和含义

### 步骤3：转移方程
- "我现在有哪些选择？"
- "每个选择会带我到什么新状态？"
- "如何从这些新状态得到当前最优解？"

### 步骤4：边界初始化
- 最小规模子问题的解
- 特殊情况的处理

### 步骤5：计算实现
- 选择迭代顺序
- 实现代码并考虑空间优化

### 步骤6：结果提取
- 从最终状态或状态数组中提取答案

---

## 五、动态规划的优化技巧

### 1. **空间优化**
```python
# 原始：O(n)空间
dp = [0] * n

# 优化：O(1)空间（当只依赖前几个状态时）
prev = curr = 0
for i in range(n):
    curr = f(prev, ...)
    prev = curr
```

### 2. **状态压缩**
```python
# 用位运算压缩状态
# 例如：dp[mask]表示选择状态为mask时的最优解
```

### 3. **斜率优化**
当转移方程具有特定形式时，可以优化时间复杂度。

---

## 六、动态规划的问题分类

### 1. **线性DP**
- 最大子数组和
- 最长递增子序列
- 背包问题

### 2. **区间DP**
- 矩阵连乘
- 石子合并

### 3. **树形DP**
- 在树结构上的动态规划

### 4. **状态压缩DP**
- 旅行商问题
- 铺砖问题

---

## 七、从最大子数组和问题学到的DP思维

```python
# 模板化思维
def dp_template(nums):
    n = len(nums)
    # 1. 状态定义和初始化
    dp = [0] * n
    dp[0] = nums[0]
    
    # 2. 状态转移
    for i in range(1, n):
        dp[i] = max(nums[i], dp[i-1] + nums[i])  # 决策点
    
    # 3. 结果提取
    return max(dp)
```

**关键洞察**：
- 每个位置只有两种选择：**重新开始**或**延续之前**
- 这种"二选一"的决策模式是很多DP问题的共性
- 状态定义要包含"以i结尾"这样的限制，确保无后效性

---

## 总结

动态规划是一种**系统性的问题求解框架**，通过本问题的学习，我们掌握了：

1. **识别条件**：最优子结构 + 重叠子问题 + 无后效性
2. **设计要素**：状态定义 → 转移方程 → 边界条件 → 计算顺序  
3. **优化思维**：空间压缩、状态简化
4. **模板化应用**：将具体问题映射到DP框架中

这种思维方式不仅适用于算法竞赛，在解决实际工程优化问题时也同样有效。
