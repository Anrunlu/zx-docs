---
title: 学生分组
icon: fas fa-beer
author: 刘一彤
order: 1
category:
  - 教学文档
tag:
  - 贪心算法
---

# 学生分组
## 1. 题目描述

有n组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 R和下界 L(L <=> R)，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 N 组学生的人数都在 [L,R] 中。

## 输入格式

第一行一个整数 n，表示学生组数；

第二行 n个整数，表示每组的学生个数；

第三行两个整数 L,R，表示下界和上界。

## 输出格式

一个数，表示最少的交换次数，如果不能满足题目条件输出 -1。

## 样例 #1

### 样例输入 #1

```
2
10 20
10 15
```

### 样例输出 #1

```
5
```

## 2. 分析
读完题目，我们就应该知道：输出有两种情况，交换次数和 -1.

先考虑输出 -1 （即不能满足题目条件）的情况：
此时有两种可能，总人数（all）大于组数（n）乘上界（r）或小于组数乘下界（l）。代码实现很简单，求出总数再比较,满足条件输出 -1 。
然后是满足条件的情况：
用 b 数组存不足下限的组一共缺少的人数，用 c 数组存超过上限的组一共超过的人数。

最简单的方法就是用 c 数组中多出的人数去补 b 数组中缺少的人数，但如果 b,c 不相等呢？

当然要使 b,c 都等于0，所以最少交换次数就是 b,c 中较大的数！这道题就做完了！

## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[51],b,c,all,l,r,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	cin>>l>>r;
    for(int i=1;i<=n;i++)
    {
        all+=a[i];
    }
	if(all<n*l||all>n*r)
	{
		cout<<"-1";
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]<l)
		{
			b+=(l-a[i]);
		}
		if(a[i]>r) c+=(a[i]-r);
	}
	cout<<max(b,c);
    return 0;
}
```