---
title: 摆动序列
icon: fas fa-layer-group
author: 周子力
order: 3
category:
  - 教学文档
tag:
  - 贪心算法
---




## 题目描述

![picture 0](https://oss.docs.z-xin.net/a21043fbf1951bc4a0b3a89fd58bb3ee5efa91c371ff30669afdbc474baef0dd.png)  

## 解题思路

这是一个关于动态规划或贪心思想的序列问题。

### 求解思路：

1. **理解摆动序列**：一个摆动序列的差值序列必须严格地在正数和负数之间交替。例如 `[..., +, -, +, - ...]` 或 `[..., -, +, -, + ...]`。如果出现 `[..., +, +, ...]` 或 `[..., -, -, ...]` 或 `[..., 0, ...]`，则不满足条件。
2. **贪心策略**：我们不需要找出所有可能的子序列，而是要找出最长的那个。一个有效的贪心策略是：**尽可能地保留那些能够改变差值符号的元素，同时跳过那些不改变符号或使序列变平的元素**。
3. **状态跟踪**：我们可以用一个变量来跟踪当前摆动序列的“方向”。例如，用一个布尔值 `is_up` 来表示上一个有效差值是正数（上升）还是负数（下降）。
4. **遍历与更新**：
    - 从数组的第二个元素开始遍历。
    - 计算当前元素与前一个元素的差值 `diff`。
    - 如果 `diff == 0`，说明这两个元素相等，它不能成为摆动序列的一部分，直接跳过。
    - 如果 `diff > 0`（上升）：
        - 如果 `is_up` 是 `False`（即上一个有效差值是下降的），那么我们找到了一个转折点，摆动序列的长度可以增加 1，并将 `is_up` 更新为 `True`。
        - 如果 `is_up` 是 `True`（即上一个有效差值也是上升的），说明我们遇到了连续的上升，这破坏了摆动性。我们应该“忽略”掉当前这个元素之前的那些使序列保持上升的元素，只保留能形成最高点的那个。因此，我们不增加长度，但可以更新 `is_up = True`（虽然值没变，但逻辑上是更新了状态）。
    - 如果 `diff < 0`（下降）：
        - 如果 `is_up` 是 `True`（即上一个有效差值是上升的），那么我们找到了一个转折点，摆动序列的长度可以增加 1，并将 `is_up` 更新为 `False`。
        - 如果 `is_up` 是 `False`（即上一个有效差值也是下降的），说明我们遇到了连续的下降。同样，我们只关心形成最低点的那个元素。因此，我们不增加长度，但可以更新 `is_up = False`。
5. **初始状态**：在开始遍历前，我们需要一个初始状态。如果数组长度为 1，直接返回 1。对于长度大于 1 的数组，我们可以先找到第一个非零差值来确定初始的 `is_up` 状态，或者使用一个特殊值（如 `None`）来表示尚未确定方向。

### Python 代码实现：

```python
def wiggleMaxLength(nums):
    """
    :param nums: List[int] - 输入的整数数组
    :return: int - 最长摆动子序列的长度
    """
    n = len(nums)
    if n <= 1:
        return n

    # 初始化最长长度为 1，因为单个元素是摆动序列
    max_length = 1
    
    # 用 None 表示尚未确定初始方向
    is_up = None

    for i in range(1, n):
        diff = nums[i] - nums[i - 1]
        
        # 如果差值为0，跳过当前元素，因为它不改变序列的摆动性
        if diff == 0:
            continue
            
        # 如果还没有确定方向（is_up 为 None），或者当前差值与上一个有效差值符号不同
        if is_up is None or diff > 0 != is_up:
            # 找到了一个转折点，长度增加
            max_length += 1
            # 更新方向状态：如果 diff > 0，则 is_up 为 True (上升)
            is_up = diff > 0
            
        # 如果 diff 的符号与 is_up 相同，则不增加长度，继续循环
        # 这种情况下的元素被视为被“跳过”或“忽略”，因为我们只关心峰值和谷值

    return max_length

# --- 示例测试 ---
# 示例 1
nums1 = [1, 7, 4, 9, 2, 5]
print(f"输入: nums = {nums1}")
print(f"输出: {wiggleMaxLength(nums1)}")  # 输出: 6
# 解释: 整个序列差值为 [6, -3, 5, -7, 3]，严格交替。

# 示例 2
nums2 = [1, 17, 5, 10, 13, 15, 10, 5, 16, 8]
print(f"输入: nums = {nums2}")
print(f"输出: {wiggleMaxLength(nums2)}")  # 输出: 7
# 解释: 例如 [1, 17, 10, 15, 5, 16, 8]，差值为 [16, -7, 5, -10, 11, -8]。

# 示例 3
nums3 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(f"输入: nums = {nums3}")
print(f"输出: {wiggleMaxLength(nums3)}")  # 输出: 2
# 解释: [1, 2] 或 [8, 9] 等，任何两个相邻且不相等的元素都可以构成长度为2的摆动序列。
```


### 摆动序列问题：注意事项与启发

#### 1. **贪心策略的理解**
- **核心启发**：这个问题的关键在于理解**贪心策略**：我们只需要关注序列中的“峰值”和“谷值”，而忽略单调递增或递减段中的中间元素。例如，在序列 `[1, 2, 3, 2, 1]` 中，我们只关心 `1`（谷）-> `3`（峰）-> `1`（谷）这三个点，中间的 `2` 和 `2` 可以被忽略。这样能保证我们得到最长的摆动子序列。
- **注意**：这种贪心策略是正确的，因为它最大化了转折点的数量，而转折点的数量直接决定了摆动序列的长度。

#### 2. **状态变量的设计**
- **`is_up` 变量**：用一个变量（如布尔值 `is_up`）来记录当前摆动序列的期望方向（上升或下降）是解决这个问题的核心。它帮助我们判断当前的差值 `diff` 是否形成了一个有效的“转折”。
- **`max_length` 变量**：它记录了到目前为止找到的最长摆动序列的长度。
- **注意**：初始状态 `is_up` 设为 `None` 是一个很好的设计，它表示我们还没有遇到第一个有效的非零差值，因此还没有确定初始方向。这避免了在开始时进行复杂的判断。

#### 3. **处理相等元素**
- **核心逻辑**：当 `diff == 0` 时，意味着 `nums[i] == nums[i-1]`。这个元素必须被跳过，因为它不产生任何“摆动”。在代码中，使用 `continue` 语句可以优雅地跳过本次循环，处理下一个元素。
- **注意**：不能简单地认为相等元素会重置序列，而是应该忽略它们，继续寻找下一个可能的转折点。

#### 4. **差值符号的判断**
- **关键判断**：`if diff > 0 != is_up:` 是代码的核心逻辑。它的含义是：如果当前差值 `diff` 的符号（正或负）与上一个有效差值的符号 `is_up` 不同，那么就找到了一个转折点。
    - `diff > 0` 会返回 `True` 或 `False`。
    - `!= is_up` 将这个布尔结果与 `is_up` (也是 `True` 或 `False` 或 `None`) 进行比较。
    - 当 `is_up` 为 `None` 时，任何 `True/False` 都不等于 `None`，所以第一个非零差值总是能触发 `max_length` 的增加。
- **注意**：这种写法简洁地处理了初始状态和方向改变两种情况。

#### 5. **边界条件**
- **单元素/两元素**：当 `n <= 1` 时，直接返回 `n`。单个元素本身就是长度为 1 的摆动序列。两个不等元素构成长度为 2 的摆动序列。
- **全相等序列**：如 `[7, 7, 7]`，所有差值都为 0，`max_length` 保持初始值 1。
- **单调序列**：如 `[1, 2, 3, 4]`，只有第一个差值 `1->2` 有效，`max_length` 增加到 2，后续差值都与 `is_up` (True) 相同，因此不再增加。最终长度为 2。

#### 6. **启发**
- **贪心 vs 动态规划**：这个问题可以用动态规划解决（维护以每个位置结尾的最长上升摆动子序列和最长下降摆动子序列），但贪心解法更简洁高效（$O(N)$ 时间，$O(1)$ 空间）。这启发我们，对于某些最优化问题，寻找一个巧妙的贪心策略可能比复杂的 DP 更优。
- **状态机思想**：`is_up` 变量的使用体现了一种简单的“状态机”思想。我们根据当前状态（`is_up`）和输入（`diff`）来决定如何更新状态和结果。这是解决许多序列问题的有力工具。
- **问题转化**：将寻找“摆动子序列”转化为寻找“转折点”的数量，是一种有效的思路转化。将复杂问题简化为其本质特征，是算法设计中常用的技巧。
- **一次遍历**：该算法只需要一次遍历就能解决问题，体现了高效算法设计的精髓。在设计算法时，应思考是否可以通过一次遍历完成任务。
