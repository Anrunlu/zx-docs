---
title: 购买物品的最大开销
icon: fas fa-beer
author: 刘秋婷
order: 1
category:
  - 教学文档
tag:
  - 贪心算法
---

# 购买物品的最大开销
## 1. 题目描述

给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 <= j < n - 1 都有 values[i][j] >= values[i][j + 1] 。

每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：

选择商店 i 。
购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。
注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。

请你返回购买所有 m * n 件物品需要的 最大开销 。

 

### 示例 1：

输入：values = [[8,5,2],[6,4,1],[9,7,3]]
输出：285
解释：第一天，从商店 1 购买物品 2 ，开销为 values[1][2] * 1 = 1 。
第二天，从商店 0 购买物品 2 ，开销为 values[0][2] * 2 = 4 。
第三天，从商店 2 购买物品 2 ，开销为 values[2][2] * 3 = 9 。
第四天，从商店 1 购买物品 1 ，开销为 values[1][1] * 4 = 16 。
第五天，从商店 0 购买物品 1 ，开销为 values[0][1] * 5 = 25 。
第六天，从商店 1 购买物品 0 ，开销为 values[1][0] * 6 = 36 。
第七天，从商店 2 购买物品 1 ，开销为 values[2][1] * 7 = 49 。
第八天，从商店 0 购买物品 0 ，开销为 values[0][0] * 8 = 64 。
第九天，从商店 2 购买物品 0 ，开销为 values[2][0] * 9 = 81 。
所以总开销为 285 。
285 是购买所有 m * n 件物品的最大总开销。

### 示例 2：
输入：values = [[10,8,6,4,2],[9,7,5,3,2]]
输出：386
解释：第一天，从商店 0 购买物品 4 ，开销为 values[0][4] * 1 = 2 。
第二天，从商店 1 购买物品 4 ，开销为 values[1][4] * 2 = 4 。
第三天，从商店 1 购买物品 3 ，开销为 values[1][3] * 3 = 9 。
第四天，从商店 0 购买物品 3 ，开销为 values[0][3] * 4 = 16 。
第五天，从商店 1 购买物品 2 ，开销为 values[1][2] * 5 = 25 。
第六天，从商店 0 购买物品 2 ，开销为 values[0][2] * 6 = 36 。
第七天，从商店 1 购买物品 1 ，开销为 values[1][1] * 7 = 49 。
第八天，从商店 0 购买物品 1 ，开销为 values[0][1] * 8 = 64 。
第九天，从商店 1 购买物品 0 ，开销为 values[1][0] * 9 = 81 。
第十天，从商店 0 购买物品 0 ，开销为 values[0][0] * 10 = 100 。
所以总开销为 386 。
386 是购买所有 m * n 件物品的最大总开销。

## 2. 分析

采用贪心算法来解决这个问题。根据题目要求，购买一件物品的开销等于物品的价值与购买的天数的乘积。由于每个商店的物品按价值降序排序且每天购买物品时可以选择一个商店中尚未购买的最大下标处的物品，因此每天购买的物品一定是其中一家商店中尚未购买的价值最低的物品，每天都可以在所有尚未购买的物品中选择购买价值最低的物品。根据贪心策略，为了使开销最大，每次都要在每个商店中尚未购买的最低价值的物品中再选出一个最低的，这样随着天数的增加，每次选择的物品的价值也是不断增加的，开销也是最大的。即每次购买的物品要按价值递增的顺序购买，才能使开销最大。

## 3. 代码

```java
class Solution {
    public long maxSpending(int[][] values) {
        int m=values.length,n=values[0].length;
        int totalCount=m*n;
        int[] allValues=new int[totalCount];
        for(int i=0;i<m;i++){
            System.arraycopy(values[i],0,allValues,i*n,n);
        }
        Arrays.sort(allValues);
        long totalCost=0;
        for(int d=1;d<=totalCount;d++){
            totalCost+=(long)allValues[d-1]*d;
        }
        return totalCost;
    }
}
```